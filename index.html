<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cosmic Uplink</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src='https://meet.jit.si/external_api.js'></script>
    <style>
        body, html { margin: 0; padding: 0; height: 100%; background-color: #000; overflow: hidden; font-family: monospace; }
        #meet-container { width: 100%; height: 100%; filter: sepia(20%) hue-rotate(180deg) saturate(120%) contrast(110%); }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%; z-index: 10;
        }
        #status { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: #0f0; padding: 10px; border-radius: 5px; z-index: 100; font-size: 14px; }
        #test-fallback { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.95); color: white; padding: 30px; border-radius: 15px; text-align: center; display: none; z-index: 1000; }
    </style>
</head>
<body>
    <div id="status">üöÄ Initializing Direct Uplink...</div>
    <div id="meet-container"></div>
    <div id="overlay"></div>
    <div id="test-fallback">
        <h3>‚ö†Ô∏è Could Not Access Camera</h3>
        <p>Testing in fallback mode. In a real match, your partner would be here.</p>
        <div id="fallback-timer">Session Timer: 05:00</div>
        <button onclick="closeFallback()" style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 5px; margin-top: 15px;">Close Test</button>
    </div>

    <script>
        const tg = window.Telegram.WebApp;
        tg.expand();
        tg.enableClosingConfirmation();

        const urlParams = new URLSearchParams(window.location.search);
        const roomName = urlParams.get('room') || 'COSMIC-VOID-' + Math.random().toString(36).substring(7);
        let api = null;

        // ==== 1. FIRST, TRY DIRECT JITSI CONNECTION (NO PROMPTS) ====
        function startDirectConnection() {
            updateStatus('üì° Bypassing all prompts...');

            const domain = 'meet.jit.si';
            const options = {
                roomName: roomName,
                width: '100%',
                height: '100%',
                parentNode: document.querySelector('#meet-container'),
                configOverwrite: {
                    // ==== CRITICAL: REMOVES ALL PROMPTS ====
                    prejoinPageEnabled: false,     // KILLS pre-join screen
                    skipMeetingPrejoin: true,      // SKIPS directly to call
                    requireDisplayName: false,     // NO name asked
                    disableDeepLinking: true,      // NO app prompts

                    // Auto-start media (may still trigger OS permission)
                    startWithAudioMuted: false,
                    startWithVideoMuted: false,

                    // Connection reliability
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ],
                    enableNoisyMicDetection: false,
                    constraints: {
                        video: { height: { ideal: 360, max: 720, min: 180 } }
                    }
                },
                interfaceConfigOverwrite: {
                    TOOLBAR_BUTTONS: ['microphone', 'camera', 'hangup', 'tileview', 'fullscreen'],
                    SHOW_JITSI_WATERMARK: false,
                    SHOW_WATERMARK_FOR_GUESTS: false,
                    MOBILE_APP_PROMO: false,
                    DEFAULT_REMOTE_DISPLAY_NAME: 'Cosmic Partner',
                    HIDE_INVITE_MORE_HEADER: true
                },
                // Auto-generated anonymous name
                userInfo: {
                    displayName: 'Anonymous'
                }
            };

            try {
                api = new JitsiMeetExternalAPI(domain, options);
                setupEventListeners();
            } catch (error) {
                console.error('Jitsi init failed:', error);
                updateStatus('‚ùå Failed. Entering test mode.');
                showFallbackTest();
            }
        }

        // ==== 2. EVENT HANDLERS ====
        function setupEventListeners() {
            if (!api) return;

            api.on('videoConferenceJoined', () => {
                updateStatus('‚úÖ Directly Joined');
                startSessionTimer(300); // 5-minute timer
            });

            api.on('videoConferenceLeft', () => {
                tg.close();
            });

            api.on('participantJoined', () => {
                updateStatus('‚ú® Partner Connected');
            });

            api.on('participantLeft', () => {
                updateStatus('üë§ Partner Left');
            });

            // Monitor connection state
            api.on('iceConnectionStateChanged', (event) => {
                console.log('ICE State:', event.state);
                if (event.state === 'failed') {
                    updateStatus('‚ö†Ô∏è Connection struggling...');
                }
            });
        }

        // ==== 3. SESSION TIMER (WORKS IN BOTH MODES) ====
        let sessionTimer = null;
        function startSessionTimer(totalSeconds) {
            let timeLeft = totalSeconds;
            const timerElement = document.getElementById('status');

            function update() {
                const minutes = Math.floor(timeLeft / 60);
                const seconds = timeLeft % 60;
                const timerText = `‚è≥ ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                // Update status or fallback display
                if (document.getElementById('test-fallback').style.display === 'block') {
                    document.getElementById('fallback-timer').textContent = `Session Timer: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    updateStatus(timerText);
                }

                if (timeLeft <= 0) {
                    endSession();
                    return;
                }
                timeLeft--;
            }

            update();
            sessionTimer = setInterval(update, 1000);
        }

        function endSession() {
            clearInterval(sessionTimer);
            updateStatus('üåå Session Complete');
            if (api) {
                api.executeCommand('hangup');
            }
            setTimeout(() => tg.close(), 2000);
        }

        // ==== 4. FALLBACK TEST MODE (IF DIRECT CONNECTION FAILS) ====
        function showFallbackTest() {
            document.getElementById('test-fallback').style.display = 'block';
            startSessionTimer(300); // Start timer in test mode too
        }

        function closeFallback() {
            document.getElementById('test-fallback').style.display = 'none';
            tg.close();
        }

        // ==== 5. HELPER ====
        function updateStatus(text) {
            document.getElementById('status').textContent = text;
        }

        // ==== 6. START EVERYTHING ====
        // Try direct connection immediately on load
        startDirectConnection();

        // If after 5 seconds we're not connected, show test fallback
        setTimeout(() => {
            if (!api || document.getElementById('status').textContent.includes('Initializing')) {
                showFallbackTest();
            }
        }, 5000);

        // Prevent accidental exit
        window.addEventListener('beforeunload', (e) => {
            e.preventDefault();
            e.returnValue = '';
        });
    </script>
</body>
</html>            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            border: 2px solid #4CAF50;
            z-index: 2000;
            text-align: center;
            max-width: 80%;
            display: none;
        }
        
        /* Aesthetic Overlay */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            z-index: 10;
        }
        
        /* STATUS INDICATOR */
        #status-indicator {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 8px 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #4CAF50;
            animation: blink 2s infinite;
        }
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
    </style>
</head>
<body>
    <!-- Status Indicator -->
    <div id="status-indicator">
        <div class="status-dot"></div>
        <span id="status-text">Initializing...</span>
    </div>
    
    <!-- Countdown Timer -->
    <div id="countdown-timer">
        <div id="timer-label">Session Ends In</div>
        <div id="timer-display">05:00</div>
    </div>
    
    <!-- Jitsi Container -->
    <div id="meet-container"></div>
    
    <!-- Test Controls (Only visible in test mode) -->
    <div id="test-controls">
        <div style="color: #FF9800; text-align: center; margin-bottom: 10px; font-size: 14px;">
            üß™ SINGLE-DEVICE TEST MODE
        </div>
        <button class="test-btn" onclick="simulatePartnerJoin()">üë§ Simulate Partner Joining</button>
        <button class="test-btn" onclick="simulatePartnerLeave()">üëã Simulate Partner Leaving</button>
        <button class="test-btn" onclick="forceEndSession()">‚èπÔ∏è Force End Session Now</button>
        <button class="test-btn" onclick="resetTimer()">üîÑ Reset Timer</button>
        <div style="margin-top: 10px; font-size: 12px; color: #888; text-align: center;">
            Room: <span id="room-display">-</span>
        </div>
    </div>
    
    <!-- Simulation Overlay -->
    <div id="simulation-overlay">
        <h3>üß™ Simulation Active</h3>
        <p>You're testing in single-device mode.</p>
        <p>In a real call, your partner would appear here.</p>
        <p>Use the test controls at the bottom to simulate different scenarios.</p>
        <button class="test-btn" onclick="closeSimulationOverlay()" style="margin-top: 15px;">
            Start Testing
        </button>
    </div>
    
    <!-- Aesthetic Overlay -->
    <div id="overlay"></div>

    <script>
        // ========== CONFIGURATION ==========
        const CONFIG = {
            // Session duration in minutes
            SESSION_DURATION_MINUTES: 5, // Change to desired duration (e.g., 10 for 10 minutes)
            
            // Test mode settings
            ENABLE_TEST_MODE: true, // Set to false in production
            AUTO_SIMULATE_PARTNER: true, // Auto-simulate partner for testing
            
            // Warning thresholds (in seconds)
            WARNING_THRESHOLD: 60, // Show warning at 60 seconds
            CRITICAL_THRESHOLD: 30, // Show critical warning at 30 seconds
        };
        
        // ========== GLOBAL VARIABLES ==========
        const tg = window.Telegram.WebApp;
        const urlParams = new URLSearchParams(window.location.search);
        const roomName = urlParams.get('room') || 'COSMIC-VOID-' + Math.random().toString(36).substring(7);
        
        let api = null;
        let sessionTimer = null;
        let timeRemaining = CONFIG.SESSION_DURATION_MINUTES * 60; // in seconds
        let isTestMode = CONFIG.ENABLE_TEST_MODE;
        let partnerSimulated = false;
        
        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        function initializeApp() {
            tg.expand();
            tg.enableClosingConfirmation();
            
            // Display room ID
            document.getElementById('room-display').textContent = roomName;
            
            // Check if we can access media (camera/mic)
            checkMediaAccess()
                .then(hasAccess => {
                    if (hasAccess || isTestMode) {
                        startJitsiSession();
                    } else {
                        showSimulationMode();
                    }
                })
                .catch(() => {
                    showSimulationMode();
                });
        }
        
        function checkMediaAccess() {
            return new Promise((resolve) => {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    resolve(false);
                    return;
                }
                
                // Try to access camera briefly
                navigator.mediaDevices.getUserMedia({ video: true, audio: true })
                    .then(stream => {
                        // Stop the test stream immediately
                        stream.getTracks().forEach(track => track.stop());
                        resolve(true);
                    })
                    .catch(() => {
                        resolve(false);
                    });
            });
        }
        
        // ========== JITSI SESSION ==========
        function startJitsiSession() {
            updateStatus('üåå Connecting to secure uplink...');
            
            const userDisplayName = tg.initDataUnsafe?.user?.first_name 
                ? "OPERATIVE " + tg.initDataUnsafe.user.first_name.toUpperCase() 
                : "UNKNOWN OPERATIVE";
        
            const domain = 'meet.jit.si';
            const options = {
                roomName: roomName,
                width: '100%',
                height: '100%',
                parentNode: document.querySelector('#meet-container'),
                configOverwrite: { 
                    startWithAudioMuted: false,
                    startWithVideoMuted: false,
                    prejoinPageEnabled: false,       // Skip "Join meeting" button
                    skipMeetingPrejoin: true,        // Direct entry
                    disableDeepLinking: true,
                    requireDisplayName: false
                },
                interfaceConfigOverwrite: {
                    TOOLBAR_BUTTONS: [
                        'microphone', 'camera', 'hangup', 'tileview', 'fullscreen', 'chat'
                    ],
                    SHOW_JITSI_WATERMARK: false,
                    SHOW_WATERMARK_FOR_GUESTS: false,
                    MOBILE_APP_PROMO: false,
                    DEFAULT_REMOTE_DISPLAY_NAME: 'Fellow Operative'
                },
                userInfo: {
                    displayName: userDisplayName
                }
            };
        
            try {
                api = new JitsiMeetExternalAPI(domain, options);
                setupEventListeners();
                
                if (isTestMode) {
                    showTestControls();
                    if (CONFIG.AUTO_SIMULATE_PARTNER) {
                        setTimeout(() => simulatePartnerJoin(), 2000);
                    }
                }
                
            } catch (error) {
                console.error('Jitsi init error:', error);
                updateStatus('‚ùå Failed to connect');
                showSimulationMode();
            }
        }
        
        // ========== EVENT LISTENERS ==========
        function setupEventListeners() {
            if (!api) return;
            
            api.addEventListener('videoConferenceJoined', handleConferenceJoined);
            api.addEventListener('videoConferenceLeft', handleConferenceLeft);
            api.addEventListener('participantJoined', handleParticipantJoined);
            api.addEventListener('participantLeft', handleParticipantLeft);
            api.addEventListener('readyToClose', handleReadyToClose);
        }
        
        function handleConferenceJoined() {
            updateStatus('‚úÖ Connected to room');
            startSessionTimer();
            
            if (isTestMode) {
                setTimeout(() => {
                    api.executeCommand('sendChatMessage', 
                        'üåå Welcome to Cosmic Connection Test Mode');
                }, 1000);
            }
        }
        
        function handleConferenceLeft() {
            updateStatus('üåå Connection terminated');
            stopSessionTimer();
            
            setTimeout(() => {
                tg.close();
            }, 2000);
        }
        
        function handleParticipantJoined() {
            updateStatus('‚ú® Partner connected!');
            partnerSimulated = false; // Real partner joined
            hideTestControls();
        }
        
        function handleParticipantLeft() {
            updateStatus('üë§ Partner disconnected');
            
            if (isTestMode) {
                showTestControls();
            }
        }
        
        function handleReadyToClose() {
            tg.close();
        }
        
        // ========== SESSION TIMER ==========
        function startSessionTimer() {
            updateTimerDisplay();
            
            sessionTimer = setInterval(() => {
                timeRemaining--;
                updateTimerDisplay();
                
                if (timeRemaining <= 0) {
                    endSession();
                } else if (timeRemaining === CONFIG.WARNING_THRESHOLD) {
                    showWarning('‚ö†Ô∏è Session ending in 1 minute!');
                } else if (timeRemaining === CONFIG.CRITICAL_THRESHOLD) {
                    showWarning('‚è≥ Session ending in 30 seconds!', true);
                }
            }, 1000);
            
            console.log(`‚è±Ô∏è Session timer started: ${CONFIG.SESSION_DURATION_MINUTES} minutes`);
        }
        
        function stopSessionTimer() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
        }
        
        function updateTimerDisplay() {
            const timerElement = document.getElementById('timer-display');
            const timerContainer = document.getElementById('countdown-timer');
            
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            
            timerElement.textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Update styling based on time remaining
            timerContainer.classList.remove('warning', 'critical');
            
            if (timeRemaining <= CONFIG.CRITICAL_THRESHOLD) {
                timerContainer.classList.add('critical');
            } else if (timeRemaining <= CONFIG.WARNING_THRESHOLD) {
                timerContainer.classList.add('warning');
            }
        }
        
        function showWarning(message, isCritical = false) {
            // Send chat message
            if (api) {
                try {
                    api.executeCommand('sendChatMessage', message);
                } catch (e) {
                    // Chat might not be available
                }
            }
            
            // Visual notification
            updateStatus(message);
            
            if (isCritical && api) {
                api.executeCommand('sendChatMessage', 
                    'üåå Cosmic connection concluding shortly...');
            }
        }
        
        function endSession() {
            stopSessionTimer();
            updateStatus('üåå Session time complete');
            
            if (api) {
                // Send final message
                api.executeCommand('sendChatMessage', 
                    '‚ú® Cosmic connection complete. Thank you!');
                
                // Leave the call
                setTimeout(() => {
                    api.executeCommand('hangup');
                }, 1000);
            } else {
                // In simulation mode
                setTimeout(() => {
                    tg.close();
                }, 2000);
            }
        }
        
        // ========== TEST/SIMULATION FUNCTIONS ==========
        function showTestControls() {
            document.getElementById('test-controls').style.display = 'flex';
        }
        
        function hideTestControls() {
            document.getElementById('test-controls').style.display = 'none';
        }
        
        function simulatePartnerJoin() {
            if (!api) return;
            
            partnerSimulated = true;
            updateStatus('üë§ Simulated partner joined');
            
            // Simulate a participant joining event
            handleParticipantJoined();
            
            // Send simulated message from "partner"
            setTimeout(() => {
                api.executeCommand('sendChatMessage', 
                    'Hello from the simulated cosmic partner!');
            }, 1500);
        }
        
        function simulatePartnerLeave() {
            if (!api) return;
            
            updateStatus('üëã Simulated partner left');
            handleParticipantLeft();
        }
        
        function forceEndSession() {
            if (confirm('End session now?')) {
                endSession();
            }
        }
        
        function resetTimer() {
            timeRemaining = CONFIG.SESSION_DURATION_MINUTES * 60;
            updateTimerDisplay();
            updateStatus('üîÑ Timer reset');
        }
        
        function showSimulationMode() {
            isTestMode = true;
            document.getElementById('simulation-overlay').style.display = 'block';
            showTestControls();
        }
        
        function closeSimulationOverlay() {
            document.getElementById('simulation-overlay').style.display = 'none';
            updateStatus('üß™ Test mode active');
        }
        
        // ========== HELPER FUNCTIONS ==========
        function updateStatus(text) {
            document.getElementById('status-text').textContent = text;
            console.log('Status:', text);
        }
        
        // Prevent accidental navigation
        window.addEventListener('beforeunload', (e) => {
            if (api || timeRemaining < CONFIG.SESSION_DURATION_MINUTES * 60) {
                e.preventDefault();
                e.returnValue = 'Are you sure you want to leave the cosmic connection?';
            }
        });
    </script>
</body>
</html>
