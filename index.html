<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>TAME Video Chat</title>
<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script src="https://cdn.jsdelivr.net/npm/livekit-client@2.5.9/dist/livekit-client.umd.min.js"></script>
<!-- Optional: Add WebRTC adapter for better mobile support -->
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

<style>
    /* --- RESET & BASE --- */
    * { 
        box-sizing: border-box; 
        -webkit-tap-highlight-color: transparent; 
        margin: 0;
        padding: 0;
    }
    body {
        margin: 0;
        background: #000;
        color: #fff;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
    }

    /* --- MAIN VIDEO CONTAINER --- */
    #app-container {
        position: relative;
        flex: 1;
        width: 100%;
        background: #000;
        overflow: hidden;
    }

    /* Remote Video - Full Screen Background */
    #remoteVideoWrapper {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #111;
        z-index: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #remoteVideo {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #000;
        transform: rotateY(180deg); /* Mirror remote video for natural viewing */
    }
    .placeholder-text {
        position: absolute;
        color: rgba(255,255,255,0.5);
        font-size: 20px;
        z-index: 1;
        text-align: center;
        padding: 20px;
    }

    /* Local Video - Floating PiP */
    #localVideoWrapper {
        position: absolute;
        bottom: 100px;
        right: 16px;
        width: 100px;
        height: 150px;
        border-radius: 12px;
        border: 2px solid rgba(255,255,255,0.3);
        overflow: hidden;
        z-index: 10;
        background: #222;
        box-shadow: 0 6px 20px rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #localVideo {
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #333;
        transform: scaleX(-1); /* Mirror local video for self-view */
    }

    /* --- CONTROLS OVERLAY --- */
    #controls-overlay {
        position: absolute;
        bottom: 30px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 24px;
        z-index: 20;
        padding-bottom: env(safe-area-inset-bottom);
    }
    .control-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        transition: all 0.2s;
        font-size: 26px;
        background: rgba(0,0,0,0.4);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }
    .control-btn:active { 
        transform: scale(0.92); 
    }
    .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    
    .btn-normal { 
        background: rgba(255,255,255,0.15); 
    }
    .btn-muted { 
        background: rgba(255,50,50,0.3); 
        position: relative; 
    }
    .btn-muted::before { 
        content: ''; 
        position: absolute; 
        width: 70%; 
        height: 3px; 
        background: #fff; 
        transform: rotate(-45deg);
        border-radius: 2px;
    }
    .btn-leave { 
        background: #ff3b30; 
        transform: rotate(135deg);
    }

    /* --- STATUS & FOOTER --- */
    #status-bar {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        padding: 12px;
        padding-top: max(12px, env(safe-area-inset-top));
        text-align: center;
        font-size: 14px;
        color: rgba(255,255,255,0.9);
        background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
        z-index: 15;
        pointer-events: none;
        font-weight: 500;
    }
    #footer {
        position: absolute;
        bottom: 10px;
        width: 100%;
        text-align: center;
        font-size: 12px;
        color: rgba(255,255,255,0.5);
        z-index: 5;
        padding-bottom: env(safe-area-inset-bottom);
    }

    /* --- MODAL --- */
    #permissionModal {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 100;
    }
    .modal-content {
        background: #1c1c1e;
        padding: 32px 24px;
        border-radius: 20px;
        text-align: center;
        width: 85%;
        max-width: 320px;
    }
    .modal-content h3 { 
        margin: 0 0 12px 0; 
        font-weight: 600; 
        color: white;
        font-size: 22px;
    }
    .modal-content p { 
        color: #aaa; 
        margin-bottom: 24px; 
        font-size: 16px; 
        line-height: 1.4;
    }
    #joinBtn {
        width: 100%;
        padding: 18px;
        border-radius: 14px;
        border: none;
        background: #0A84FF;
        color: white;
        font-size: 18px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
    }
    #joinBtn:hover { 
        background: #007AFF; 
    }
    #joinBtn:disabled { 
        opacity: 0.5; 
        cursor: not-allowed;
    }

    /* Connection indicators */
    .connection-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 8px;
    }
    .connected { background: #4CD964; }
    .connecting { background: #FFCC00; }
    .disconnected { background: #FF3B30; }
</style>
</head>

<body>

<div id="permissionModal">
    <div class="modal-content">
        <h3>Video Call</h3>
        <p>Allow access to your camera and microphone to start the video call.</p>
        <button id="joinBtn">Join Call</button>
    </div>
</div>

<div id="app-container">
    <div id="status-bar">
        <span class="connection-indicator disconnected"></span>
        <span id="status-text">Ready to connect...</span>
    </div>

    <div id="remoteVideoWrapper">
        <div class="placeholder-text">Waiting for other participants...</div>
        <video id="remoteVideo" autoplay playsinline></video>
    </div>
    
    <div id="localVideoWrapper">
        <video id="localVideo" autoplay muted playsinline></video>
    </div>

    <div id="controls-overlay">
        <button id="micBtn" class="control-btn btn-normal">ðŸŽ¤</button>
        <button id="leaveBtn" class="control-btn btn-leave">ðŸ“ž</button>
        <button id="camBtn" class="control-btn btn-normal">ðŸ“·</button>
    </div>

    <div id="footer">TAME Video Chat</div>
</div>

<script>
    // ==============================
    // 1. INITIALIZATION & VARIABLES
    // ==============================
    const statusEl = document.getElementById("status-text");
    const statusIndicator = document.querySelector('.connection-indicator');
    const modal = document.getElementById("permissionModal");
    const joinBtn = document.getElementById("joinBtn");
    const localVideoEl = document.getElementById("localVideo");
    const remoteVideoEl = document.getElementById("remoteVideo");
    const placeholderText = document.querySelector(".placeholder-text");
    const localVideoWrapper = document.getElementById("localVideoWrapper");
    const remoteVideoWrapper = document.getElementById("remoteVideoWrapper");
    
    // Configuration
    const LIVEKIT_URL = "wss://video-20qatdd3.livekit.cloud";
    let room = null;
    let localStream = null;
    let micEnabled = true;
    let camEnabled = true;
    let isConnecting = false;

    // ==============================
    // 2. UTILITY FUNCTIONS
    // ==============================
    function updateStatus(msg, type = 'info') {
        console.log(`[${type.toUpperCase()}] ${msg}`);
        statusEl.textContent = msg;
        
        switch(type) {
            case 'connected':
                statusIndicator.className = 'connection-indicator connected';
                statusEl.style.color = 'rgba(255,255,255,0.9)';
                break;
            case 'error':
                statusIndicator.className = 'connection-indicator disconnected';
                statusEl.style.color = '#ff3b30';
                break;
            case 'warning':
                statusIndicator.className = 'connection-indicator connecting';
                statusEl.style.color = '#FFCC00';
                break;
            default:
                statusIndicator.className = 'connection-indicator connecting';
                statusEl.style.color = 'rgba(255,255,255,0.9)';
        }
    }

    function updateButtonStates() {
        const micBtn = document.getElementById("micBtn");
        const camBtn = document.getElementById("camBtn");
        
        // Update microphone button
        if (micEnabled) {
            micBtn.classList.remove("btn-muted");
            micBtn.classList.add("btn-normal");
            micBtn.innerHTML = "ðŸŽ¤";
        } else {
            micBtn.classList.remove("btn-normal");
            micBtn.classList.add("btn-muted");
            micBtn.innerHTML = "ðŸŽ¤";
        }
        
        // Update camera button
        if (camEnabled) {
            camBtn.classList.remove("btn-muted");
            camBtn.classList.add("btn-normal");
            camBtn.innerHTML = "ðŸ“·";
            localVideoWrapper.style.display = 'flex';
        } else {
            camBtn.classList.remove("btn-normal");
            camBtn.classList.add("btn-muted");
            camBtn.innerHTML = "ðŸ“·";
            localVideoWrapper.style.display = 'none';
        }
    }

    // ==============================
    // 3. PERMISSION & JOIN HANDLER
    // ==============================
    joinBtn.onclick = async () => {
        if (isConnecting) return;
        
        isConnecting = true;
        joinBtn.disabled = true;
        joinBtn.textContent = "Connecting...";
        updateStatus("Requesting camera and microphone...", 'warning');
        
        try {
            // Request camera and microphone access with better constraints
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    channelCount: 2
                },
                video: {
                    width: { ideal: 640, min: 320, max: 1280 },
                    height: { ideal: 480, min: 240, max: 720 },
                    frameRate: { ideal: 24, min: 15 },
                    facingMode: 'user',
                    aspectRatio: 4/3
                }
            });
            
            // Show local video preview immediately
            localVideoEl.srcObject = localStream;
            localVideoWrapper.style.display = 'flex';
            
            // Play local video (muted as required by browsers)
            await localVideoEl.play().catch(e => {
                console.warn("Local video play warning:", e);
            });
            
            updateStatus("Permissions granted", 'connected');
            
            // Hide modal and connect to LiveKit
            modal.style.display = "none";
            await connectToLiveKit();
            
        } catch (error) {
            console.error("Permission error:", error);
            isConnecting = false;
            
            let errorMsg = "Could not access camera/microphone. ";
            if (error.name === 'NotAllowedError') {
                errorMsg = "Please allow camera & microphone access in your browser settings.";
            } else if (error.name === 'NotFoundError') {
                errorMsg = "No camera or microphone found. Please check your device.";
            } else if (error.name === 'NotReadableError') {
                errorMsg = "Device is in use by another application.";
            } else if (error.name === 'OverconstrainedError') {
                errorMsg = "Cannot satisfy camera constraints. Try different settings.";
            } else {
                errorMsg = `Error: ${error.message}`;
            }
            
            updateStatus(errorMsg, 'error');
            joinBtn.disabled = false;
            joinBtn.textContent = "Try Again";
            modal.style.display = "flex";
        }
    };

    // ==============================
    // 4. LIVEKIT CONNECTION - FIXED VERSION
    // ==============================
    async function connectToLiveKit() {
        // Get token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get("token");
        
        if (!token) {
            updateStatus("Error: No connection token provided", 'error');
            modal.style.display = "flex";
            joinBtn.disabled = false;
            joinBtn.textContent = "Join Call";
            isConnecting = false;
            return;
        }

        updateStatus("Connecting to video server...", 'warning');

        try {
            // Create room with proper configuration
            room = new LivekitClient.Room({
                adaptiveStream: true,
                dynacast: true,
                videoCaptureDefaults: {
                    resolution: LivekitClient.VideoPresets.h540.resolution,
                    facingMode: 'user'
                },
                publishDefaults: {
                    videoCodec: 'vp8',
                    dtx: true,
                    simulcast: true,
                    videoEncoding: {
                        maxBitrate: 300000,
                        maxFramerate: 24
                    }
                }
            });

            // ==============================
            // EVENT HANDLERS
            // ==============================

            // When connected to room
            room.on(LivekitClient.RoomEvent.Connected, () => {
                updateStatus("Connected to room", 'connected');
                console.log("Connected to room, local identity:", room.localParticipant.identity);
                
                // Publish local tracks from our stream
                if (localStream) {
                    publishLocalTracks(localStream);
                }
            });

            // When local track is published (YOUR VIDEO)
            room.on(LivekitClient.RoomEvent.LocalTrackPublished, (publication) => {
                console.log("Local track published:", publication.kind);
                
                if (publication.kind === 'video') {
                    const track = publication.track;
                    
                    // FIX: Use track.attach() for proper LiveKit integration
                    track.attach(localVideoEl);
                    
                    // Ensure local video wrapper stays visible
                    localVideoWrapper.style.display = 'flex';
                    
                    // Play the video
                    localVideoEl.play().catch(e => {
                        console.warn("Local video play error:", e);
                    });
                }
            });

            // When subscribed to remote track (OTHER USER'S VIDEO)
            room.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
                console.log(`Subscribed to ${participant.identity}'s ${track.kind} track`);
                
                if (track.kind === "video") {
                    // Hide placeholder
                    placeholderText.style.display = 'none';
                    
                    // FIX: Use track.attach() instead of srcObject
                    track.attach(remoteVideoEl);
                    
                    // Play the video (muted if autoplay blocked)
                    remoteVideoEl.play().catch(e => {
                        console.log("Remote video autoplay blocked, trying muted...");
                        remoteVideoEl.muted = true;
                        remoteVideoEl.play();
                    });
                    
                    updateStatus(`Connected to ${participant.identity || 'user'}`, 'connected');
                    
                } else if (track.kind === "audio") {
                    // Create audio element for remote audio
                    const audioEl = new Audio();
                    audioEl.autoplay = true;
                    
                    // FIX: Attach audio track properly
                    track.attach(audioEl);
                    
                    // Add to DOM (hidden)
                    audioEl.style.display = 'none';
                    document.body.appendChild(audioEl);
                    
                    audioEl.play().catch(e => {
                        console.log("Audio autoplay blocked:", e);
                    });
                }
            });

            // When remote track is unsubscribed
            room.on(LivekitClient.RoomEvent.TrackUnsubscribed, (track, publication, participant) => {
                console.log(`Unsubscribed from ${participant.identity}'s ${track.kind}`);
                
                if (track.kind === "video") {
                    // Detach track from video element
                    track.detach(remoteVideoEl);
                    
                    // Show placeholder
                    remoteVideoEl.srcObject = null;
                    placeholderText.style.display = 'block';
                    placeholderText.textContent = `${participant.identity || 'User'} disconnected`;
                }
            });

            // Participant connected
            room.on(LivekitClient.RoomEvent.ParticipantConnected, (participant) => {
                console.log(`${participant.identity} joined`);
                updateStatus(`${participant.identity} joined`, 'connected');
            });

            // Participant disconnected
            room.on(LivekitClient.RoomEvent.ParticipantDisconnected, (participant) => {
                console.log(`${participant.identity} left`);
                updateStatus(`${participant.identity} left`, 'warning');
                
                // Show placeholder if this was the only remote participant
                setTimeout(() => {
                    if (room.remoteParticipants.size === 0) {
                        placeholderText.style.display = 'block';
                        placeholderText.textContent = 'Waiting for others...';
                    }
                }, 1000);
            });

            // Connection state changes
            room.on(LivekitClient.RoomEvent.ConnectionStateChanged, (state) => {
                console.log("Connection state changed to:", state);
                
                if (state === 'connected') {
                    updateStatus("Call Active", 'connected');
                    isConnecting = false;
                } else if (state === 'connecting') {
                    updateStatus("Connecting...", 'warning');
                } else if (state === 'reconnecting') {
                    updateStatus("Reconnecting...", 'warning');
                } else if (state === 'disconnected') {
                    handleLeave();
                }
            });

            // Track mute/unmute events
            room.on(LivekitClient.RoomEvent.TrackMuted, (publication, participant) => {
                console.log(`${participant.identity}'s ${publication.kind} muted`);
            });

            room.on(LivekitClient.RoomEvent.TrackUnmuted, (publication, participant) => {
                console.log(`${participant.identity}'s ${publication.kind} unmuted`);
            });

            // ==============================
            // CONNECT TO LIVEKIT
            // ==============================
            await room.connect(LIVEKIT_URL, token, {
                autoSubscribe: true,
                maxRetries: 3,
                timeout: 10000
            });
            
            updateStatus("Ready for video call", 'connected');
            updateButtonStates();

        } catch (error) {
            console.error("LiveKit connection error:", error);
            updateStatus(`Connection failed: ${error.message}`, 'error');
            
            // Clean up
            if (room) {
                room.disconnect();
                room = null;
            }
            
            // Show modal again
            modal.style.display = "flex";
            joinBtn.disabled = false;
            joinBtn.textContent = "Retry Connection";
            isConnecting = false;
            document.querySelector(".modal-content p").textContent = 
                "Connection failed. Please check your internet and try again.";
        }
    }

    // Publish local tracks
    async function publishLocalTracks(stream) {
        try {
            const audioTrack = stream.getAudioTracks()[0];
            const videoTrack = stream.getVideoTracks()[0];
            
            if (audioTrack && micEnabled) {
                await room.localParticipant.publishTrack(audioTrack, {
                    name: 'microphone',
                    source: LivekitClient.Track.Source.Microphone,
                });
                console.log("Published audio track");
            }
            
            if (videoTrack && camEnabled) {
                await room.localParticipant.publishTrack(videoTrack, {
                    name: 'camera',
                    source: LivekitClient.Track.Source.Camera,
                });
                console.log("Published video track");
            }
            
        } catch (error) {
            console.error("Error publishing tracks:", error);
            updateStatus("Error publishing media", 'error');
        }
    }

    // ==============================
    // 5. CONTROL BUTTONS
    // ==============================
    document.getElementById("micBtn").onclick = async () => {
        if (!room) return;
        
        try {
            if (micEnabled) {
                await room.localParticipant.setMicrophoneEnabled(false);
                micEnabled = false;
                updateStatus("Microphone muted", 'warning');
            } else {
                await room.localParticipant.setMicrophoneEnabled(true);
                micEnabled = true;
                updateStatus("Microphone unmuted", 'connected');
            }
            updateButtonStates();
        } catch (error) {
            console.error("Error toggling microphone:", error);
            updateStatus("Error with microphone", 'error');
        }
    };

    document.getElementById("camBtn").onclick = async () => {
        if (!room) return;
        
        try {
            if (camEnabled) {
                await room.localParticipant.setCameraEnabled(false);
                camEnabled = false;
                updateStatus("Camera off", 'warning');
            } else {
                await room.localParticipant.setCameraEnabled(true);
                camEnabled = true;
                updateStatus("Camera on", 'connected');
            }
            updateButtonStates();
        } catch (error) {
            console.error("Error toggling camera:", error);
            updateStatus("Error with camera", 'error');
        }
    };

    document.getElementById("leaveBtn").onclick = () => {
        if (confirm("End the video call?")) {
            handleLeave();
        }
    };

    // ==============================
    // 6. CLEANUP FUNCTIONS
    // ==============================
    function handleLeave() {
        updateStatus("Ending call...", 'warning');
        
        // Stop all media tracks
        if (localStream) {
            localStream.getTracks().forEach(track => {
                track.stop();
                track.enabled = false;
            });
            localStream = null;
        }
        
        // Clear video elements
        localVideoEl.srcObject = null;
        remoteVideoEl.srcObject = null;
        
        // Disconnect from LiveKit
        if (room) {
            room.disconnect();
            room = null;
        }
        
        // Reset states
        micEnabled = true;
        camEnabled = true;
        isConnecting = false;
        
        // Close or reload
        setTimeout(() => {
            if (window.Telegram?.WebApp) {
                Telegram.WebApp.close();
            } else {
                window.location.reload();
            }
        }, 500);
    }

    // ==============================
    // 7. EVENT LISTENERS & INIT
    // ==============================
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            updateStatus("Call is running in background", 'warning');
        } else if (room) {
            updateStatus("Call Active", 'connected');
        }
    });

    // Handle page unload
    window.addEventListener('beforeunload', () => {
        if (room) {
            room.disconnect();
        }
    });

    // Prevent context menu
    document.addEventListener('contextmenu', (e) => e.preventDefault());

    // Error handling
    window.addEventListener('error', (e) => {
        console.error('Global error:', e.error);
        updateStatus(`Error: ${e.message}`, 'error');
    });

    // Initialize button states
    updateButtonStates();

    // Auto-join if token is present in URL (for testing)
    window.addEventListener('load', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get("token");
        const autoJoin = urlParams.get("autojoin");
        
        if (token && autoJoin === "true") {
            console.log("Auto-joining with token...");
            joinBtn.click();
        }
        
        // Initialize Telegram Web App
        if (window.Telegram?.WebApp) {
            Telegram.WebApp.ready();
            Telegram.WebApp.expand();
            Telegram.WebApp.enableClosingConfirmation();
            updateStatus("Telegram Web App ready", 'connected');
        }
    });
</script>
</body>
</html>
